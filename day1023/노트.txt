다음의 코드에서 a의; 이름과 나이,
b의 이름과 나이는 별도의 메모리 공간이 필요한 것이 마땅
하지만 상수인 addr은 굳이 별도의 메모리가 필요하진 않으니
static을 사용하여 전역 변수로 선언하는게 효율적이다.
하지만 반대로 static을 사용해야한다고 했을 때 무조건 final이 효율적이진 않다.

클래스의 세상에서는
이미 있는 클래스를 얼마든지 확장하여 새로운 클래스를 만들 수 있다.
또, 필요하다면 얼마든지 부모의 메소드를 나한테 맞게 재정의 가능

<< final >>

변수명 앞에 final
	==> 변수이기는 하지만 마치 상수처럼 처음 정해진 값 이외 다른 값을 가질 수 없음
	
메소드명 앞에 final
	==> 오버라이딩 금지!
		이 메소드는 여기가 마지막이라, 자식클래스들이 재정의 하여 바꾸는 것을 금지
		
클래스명 앞에 final
	==> 상속금지
		이클래스가 여기가 마지막, 이 클래스를 확장하여 새로운 것을 추가하는 것을 금지
		

<< 다형성 >>
a,b,c라는 객체를 만들고 모두 동일하게 메세지(draw)를 시켰는데
객체마다 하는 일이 각각 다르다.(다르게 동작함)
이것을 객체지향 프로그램의 특징 중에 "다형성"이라고 한다.
그러니 "다형성"은 상속과 메소드 오버라이딩과 연관이 있다.

<< 객체지향 프로그래밍의 특징 >>
1) 은닉성(Encapsulation)
	외부의 다른 클래스로 부터 멤버를 보호하기 위한 개념이며
	이것에 접근하기 위해서는 public에 있는 메소드를 통해 접근 가능
	일반적으로 클래스를 만들 때 모든 멤버 변수들은 private에 두고
	메소드들은 public에 둔다.
	그러나 필요하다면 멤버변수이기는 하지만 public에 둘 수 있고
	메소드지만 private에 둘 수 있다.
	
2) 상속성(Inheritance)
	이미 만들어진 클래스를 확장하여 새로운 클래스를 만드는 것을 말하며
	코드의 재사용성을 높일 수 있어 개발시간 및 비용을 줄일 수 있다.
	
3) 다형성(Polymorphism)
	상속관게에 있을 때 자식클래스 마다 재정의 된 메소드를
	호출했을 때 동일한 메세지를 받았으나 각 객체마다
	다르게 동작하는 것을 말한다.
	
	



